#### [225\. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)
使用队列实现栈的下列操作：

push(x) -- 元素 x 入栈
pop() -- 移除栈顶元素
top() -- 获取栈顶元素
empty() -- 返回栈是否为空
注意:

你只能使用队列的基本操作-- 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。
你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。
你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。
# 方法一：使用单队列（list）实现
使用一个队列，队列添加元素后，反转前n-1个元素，栈顶元素始终保留在队首
```
class MyStack:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.q = []

    def push(self, x: int) -> None:
        """
        Push element x onto stack.
        """
        self.q.append(x)
        q_length = len(self.q)
        while q_length > 1:
            self.q.append(self.q.pop(0)) #反转前n-1个元素，栈顶元素始终保留在队首
            q_length -= 1

    def pop(self) -> int:
        """
        Removes the element on top of the stack and returns that element.
        """
        return self.q.pop(0)

    def top(self) -> int:
        """
        Get the top element.
        """
        return self.q[0]


    def empty(self) -> bool:
        """
        Returns whether the stack is empty.
        """
        return not bool(self.q)


# Your MyStack object will be instantiated and called as such:
# obj = MyStack()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.top()
# param_4 = obj.empty()

```
#方法二 使用双队列（deque）实现
```
from collections import deque
class MyStack:
    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.data = deque()
        self.help = deque()
    def push(self, x: int) -> None:
        """
        Push element x onto stack.
        """
        self.data.append(x)
    def pop(self) -> int:
        """
        Removes the element on top of the stack and returns that element.
        """
        while len(self.data) > 1:
            self.help.append(self.data.popleft())
        tmp = self.data.popleft()        
        self.help,self.data = self.data,self.help
        return tmp
    def top(self) -> int:
        """
        Get the top element.
        """
        while len(self.data) != 1:
            self.help.append(self.data.popleft())
        tmp = self.data.popleft()
        self.help.append(tmp)
        self.help,self.data = self.data,self.help
        return tmp
    def empty(self) -> bool:
        """
        Returns whether the stack is empty.
        """
        return not bool(self.data)

```
#### [206\. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)
反转一个单链表。

示例:

输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
进阶:
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？
#方法一：迭代
```
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        prev, curr = None, head
        while curr is not None:
            nextTemp = curr.next
            curr.next = prev
            prev, curr = curr, nextTemp
        return prev
```
#方法二：递归
```
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        if head is None or head.next is None: 
            return head
        p = self.reverseList(head.next)
        head.next.next = head
        head.next = None
        return p
```
---
#### [面试题 10.01\. 合并排序的数组](https://leetcode-cn.com/problems/sorted-merge-lcci/)
给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。

初始化 A 和 B 的元素数量分别为 m 和 n。

示例:

输入:
A = [1,2,3,0,0,0], m = 3
B = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]
#方法1：逆向双指针
```
class Solution:
    def merge(self, A: List[int], m: int, B: List[int], n: int) -> None:
        """
        Do not return anything, modify A in-place instead.
        """
        pa, pb = m-1, n-1
        tail = m+n-1
        while 0 <= pa or 0 <= pb: #至少有一个list还有数组未扫描完
            if pa == -1:    #A已扫描完成，B[pb]是最后一位未扫描的元素
                A[tail] = B[pb]
                pb -= 1
            elif pb == -1:
                A[tail] = A[pa]
                pa -= 1
            elif A[pa] < B[pb]:
                A[tail] = B[pb]
                pb -= 1
            else:
                A[tail] = A[pa]
                pa -= 1
            tail -= 1
```
#方法 2: 双指针
```
class Solution:
    def merge(self, A: List[int], m: int, B: List[int], n: int) -> None:
        """
        Do not return anything, modify A in-place instead.
        """
        sorted = []
        pa, pb = 0, 0
        while pa < m or pb < n:
            if pa == m:
                sorted.append(B[pb])
                pb += 1
            elif pb == n:
                sorted.append(A[pa])
                pa += 1
            elif A[pa] < B[pb]:
                sorted.append(A[pa])
                pa += 1
            else:
                sorted.append(B[pb])
                pb += 1
        A[:] = sorted
```
#方法3: 直接合并后排序
```
class Solution:
    def merge(self, A: List[int], m: int, B: List[int], n: int) -> None:
        """
        Do not return anything, modify A in-place instead.
        """
        A[m:] = B
        A.sort()
```
#### [994\. 腐烂的橘子](https://leetcode-cn.com/problems/rotting-oranges/)
在给定的网格中，每个单元格可以有以下三个值之一：

值 0 代表空单元格；
值 1 代表新鲜橘子；
值 2 代表腐烂的橘子。
每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。

返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。

 

示例 1：
![](https://upload-images.jianshu.io/upload_images/21384689-67b584b4366ed27d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)




输入：[[2,1,1],[1,1,0],[0,1,1]]
输出：4
示例 2：

输入：[[2,1,1],[0,1,1],[1,0,1]]
输出：-1
解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。
示例 3：

输入：[[0,2]]
输出：0
解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。
 

提示：

1 <= grid.length <= 10
1 <= grid[0].length <= 10
grid[i][j] 仅为 0、1 或 2

# BFS
```
class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
#  (0, 0) |--->  x
#         |
#         v  y
        m, n = len(grid), len(grid[0]) # m行 n列
        visit = [[False]*n for y in range(m)]
        stack = [[y, x] for y in range(m) for x in range(n) if grid[y][x] == 2]
        direction = [[-1, 0], [1, 0], [0, -1], [0, 1]]
        minute = 0
        while True:
            stack_next = []
            while stack:
                y, x = stack.pop()
                for d in direction:
                    y_new, x_new = y + d[0], x + d[1]
                    if -1 < y_new < m and -1 < x_new < n and not visit[y_new][x_new] and grid[y_new][x_new] == 1:
                        visit[y_new][x_new] = True
                        grid[y_new][x_new] = 2
                        stack_next.append([y_new, x_new])
            if not stack_next: break
            stack = stack_next
            minute += 1
        return -1 if ['svrvive' for y in range(m) for x in range(n) if grid[y][x] == 1] else minute
```
---
#### [1103\. 分糖果 II](https://leetcode-cn.com/problems/distribute-candies-to-people/)
排排坐，分糖果。

我们买了一些糖果 candies，打算把它们分给排好队的 n = num_people 个小朋友。

给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 n 颗糖果。

然后，我们再回到队伍的起点，给第一个小朋友 n + 1 颗糖果，第二个小朋友 n + 2 颗，依此类推，直到给最后一个小朋友 2 * n 颗糖果。

重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。

返回一个长度为 num_people、元素之和为 candies 的数组，以表示糖果的最终分发情况（即 ans[i] 表示第 i 个小朋友分到的糖果数）。

 

示例 1：

输入：candies = 7, num_people = 4
输出：[1,2,3,1]
解释：
第一次，ans[0] += 1，数组变为 [1,0,0,0]。
第二次，ans[1] += 2，数组变为 [1,2,0,0]。
第三次，ans[2] += 3，数组变为 [1,2,3,0]。
第四次，ans[3] += 1（因为此时只剩下 1 颗糖果），最终数组变为 [1,2,3,1]。
示例 2：

输入：candies = 10, num_people = 3
输出：[5,2,3]
解释：
第一次，ans[0] += 1，数组变为 [1,0,0]。
第二次，ans[1] += 2，数组变为 [1,2,0]。
第三次，ans[2] += 3，数组变为 [1,2,3]。
第四次，ans[0] += 4，最终数组变为 [5,2,3]。
 

提示：

1 <= candies <= 10^9
1 <= num_people <= 1000

```
class Solution:
    def distributeCandies(self, candies: int, num_people: int) -> List[int]:
        res = [0] * num_people
        i = 0
        while candies != 0:
            res[i % num_people] +=  min(i+1, candies)
            candies -= min(i+1, candies)
            i += 1 # 下一位
        return res
```
---
#### [面试题57 - II. 和为s的连续正数序列](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)
输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。

序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。

 

示例 1：

输入：target = 9
输出：[[2,3,4],[4,5]]
示例 2：

输入：target = 15
输出：[[1,2,3,4,5],[4,5,6],[7,8]]
 

限制：

1 <= target <= 10^5
```
class Solution:
    def findContinuousSequence(self, target: int) -> List[List[int]]:
        l, r, res = 1, 2, []
        while r <= target//2 +1:
            cur_sum = sum(list(range(l, r+1)))
            if cur_sum < target:
                r += 1
            elif cur_sum > target:
                l += 1
            else:
                res.append(list(range(l, r+1)))
                r += 1
        return res

```
---



#### [面试题59 - II. 队列的最大值](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/)
请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。

若队列为空，pop_front 和 max_value 需要返回 -1

示例 1：

输入: 
["MaxQueue","push_back","push_back","max_value","pop_front","max_value"]
[[],[1],[2],[],[],[]]
输出: [null,null,null,2,1,2]
示例 2：

输入: 
["MaxQueue","pop_front","max_value"]
[[],[],[]]
输出: [null,-1,-1]
 

限制：

1 <= push_back,pop_front,max_value的总操作数 <= 10000
1 <= value <= 10^5

```
class MaxQueue:
    
    def __init__(self):
        self.queue = []
        self.max_deque = [] #单调递减

    def max_value(self) -> int:
        return self.max_deque[0] if self.max_deque else -1

    def push_back(self, value: int) -> None:
        while self.max_deque and self.max_deque[-1] < value:
            self.max_deque.pop()
        self.max_deque.append(value)
        self.queue.append(value)

    def pop_front(self) -> int:
        if not self.max_deque: return -1
        res = self.queue.pop(0)
        if res == self.max_deque[0]:
            self.max_deque.pop(0)
        return res




# Your MaxQueue object will be instantiated and called as such:
# obj = MaxQueue()
# param_1 = obj.max_value()
# obj.push_back(value)
# param_3 = obj.pop_front()
```
```
import queue
class MaxQueue:
    """队列+双端队列"""

    def __init__(self):
        self.queue = queue.Queue()
        self.max_deque = queue.deque()

    def max_value(self) -> int:
        return self.max_deque[0] if self.max_deque else -1

    def push_back(self, value: int) -> None:
        while self.max_deque and self.max_deque[-1] < value:
            self.max_deque.pop()
        self.max_deque.append(value)
        self.queue.put(value)

    def pop_front(self) -> int:
        if not self.max_deque: return -1
        res = self.queue.get()
        if res == self.max_deque[0]:
            self.max_deque.popleft()
        return res
    
# Your MaxQueue object will be instantiated and called as such:
# obj = MaxQueue()
# param_1 = obj.max_value()
# obj.push_back(value)
# param_3 = obj.pop_front()

```
---
#### [322\. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)
给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

示例 1:

输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1
示例 2:

输入: coins = [2], amount = 3
输出: -1
说明:
你可以认为每种硬币的数量是无限的。
## dp 数组的迭代解法
## Python3
![](https://upload-images.jianshu.io/upload_images/21384689-daf3b2806ea5ba5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
## 最优解
```
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        # 数组大小为 amount + 1，初始值也为 amount + 1
        dp = [(amount+1)] * (amount+1)
        dp[0] = 0
        for i in range(len(dp)):
            # 内层 for 在求所有子问题 + 1 的最小值
            for coin in coins:
                # 子问题无解，跳过
                if(i - coin < 0): continue
                dp[i] = min(dp[i], 1 + dp[i - coin])
    
        return dp[amount] if dp[amount] != amount+1 else -1
```
## C++
![](https://upload-images.jianshu.io/upload_images/21384689-00db8b8c2c629042.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        // 数组大小为 amount + 1，初始值也为 amount + 1
        vector<int> dp(amount+1, amount+1); 
        dp[0] = 0;
        for(int i = 0; i < dp.size(); i ++ ){
            // 内层 for 在求所有子问题 + 1 的最小值
            for(int coin : coins){
                // 子问题无解，跳过
                if(i - coin < 0) continue;
                dp[i] = min(dp[i], 1 + dp[i - coin]);
            }  
        }
        //条件成立返回-1,否则返回dp[amount]
        return (dp[amount] == amount+1) ? -1 : dp[amount]; 
    }
};
```

## 方法一：暴力递归（超时）
![](https://upload-images.jianshu.io/upload_images/21384689-a5ef976cdc0e40fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        def dp(n):
            if n == 0: return 0 # base case
            if n < 0: return -1
            res = float('INF') # 求最小值，所以初始化为正无穷
            for coin in coins:
                subProblom = dp(n - coin)
                if subProblom == -1: continue # 子问题无解，跳过
                res = min(res, 1 + subProblom)
            return res if res != float('INF') else -1
        return dp(amount)

```
---
## 方法二：带备忘录的递归，优化方法一（通过）
![](https://upload-images.jianshu.io/upload_images/21384689-cb4badffe0b9849b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        memo = dict() # 备忘录
        def dp(n):
            if n in memo: return memo[n] # 查备忘录，避免重复计算

            if n == 0: return 0 # base case
            if n < 0: return -1
            res = float('INF') # 求最小值，所以初始化为正无穷
            for coin in coins:
                subProblom = dp(n - coin)
                if subProblom == -1: continue # 子问题无解，跳过
                res = min(res, 1 + subProblom)
                
            memo[n] = res if res != float('INF') else -1 # 记入备忘录
            return memo[n]
        return dp(amount)
```
## 方法三：dp 数组的迭代解法
![](https://upload-images.jianshu.io/upload_images/21384689-b4d6301d8574c436.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
```
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        dp = [float('INF')]*(amount + 1)
        dp[0]  = 0 

        for coin in coins:
            for x in range(coin, amount+1):
                dp[x] = min(dp[x], dp[x-coin]+1)
        return dp[amount] if dp[amount] != float('INF') else -1
```
#### [121\. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。

注意你不能在买入股票前卖出股票。

示例 1:

输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
示例 2:

输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
![](https://upload-images.jianshu.io/upload_images/21384689-74b170e7fcb0ae4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        inf = int(1e9)
        minprice = inf
        maxprofit = 0
        for price in prices:
            maxprofit = max(maxprofit, price - minprice)
            minprice = min(minprice, price)
        return maxprofit
```
# C+++
```
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int inf = 1e9;
        int minprice = inf, maxprofit = 0;
        for(int price : prices){
            maxprofit = max(maxprofit, price - minprice);
            minprice = min(minprice, price);
        }
        return maxprofit;

    }
};
```

## 方法1：
![](https://upload-images.jianshu.io/upload_images/21384689-87958cd2da15cd8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
 O(n) O(1)
```python []
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if len(prices) < 2:
            return 0
        min_price = prices[0]
        max_profit = 0
        for price in prices:
            if price < min_price:
                min_price = price
            if price - min_price > max_profit:
                max_profit = price - min_price
        return max_profit
```
## 方法2：dp 
![](https://upload-images.jianshu.io/upload_images/21384689-4adeaf810840dc7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

 O(n) O(n)
```python []
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if len(prices) < 2:
            return 0
        min_price = prices[0]
        dp = [0] * (n := len(prices))
        for i in range(n):
            # 第i天最大利润 = max（第i-1天最大利润，第i天可能的最大利润
            dp[i] = max(dp[i-1], prices[i] - min_price )
            min_price = min(min_price, prices[i])
        return dp[-1]

```
## 方法3：dp 优化

![](https://upload-images.jianshu.io/upload_images/21384689-9b6172bb9a3c1676.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
 O(n) O(1)

### 代码

```python []
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if len(prices) < 2:
            return 0
        min_price = prices[0]
        max_profit = 0
        for i in range(len(prices)):
            max_profit = max(prices[i]-min_price, max_profit)
            min_price = min(min_price, prices[i])
        return max_profit
```
#### [543\. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)
给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。

示例 :
给定二叉树
```
          1
         / \
        2   3
       / \     
      4   5    
```
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

注意：两结点之间的路径长度是以它们之间边的数目表示。
## C++ 
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int ans = 0;
    int diameterOfBinaryTree(TreeNode* root) {
        dfs(root);
        return ans;
    }
    int dfs(TreeNode * root){
        if (!root) return 0;
        auto left = dfs(root->left);
        auto right = dfs(root->right);
        ans = max(ans, left + right);

        return max(left + 1, right + 1);
    }
};

```
# Python3
```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        self.ans = 0
        def dfs(root):
            if not root: return 0
            left = dfs(root.left)
            right = dfs(root.right)
            self.ans = max(self.ans, left + right)

            return max(left + 1, right + 1)
        dfs(root)
        return self.ans
```
```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        self.ans = 1
        def depth(node):
            if not node: return 0
            L = depth(node.left)
            R = depth(node.right)
            self.ans = max(self.ans, L + R + 1)
            return max(L, R) + 1
        
        depth(root)
        return self.ans -1
```
---

#### [1013\. 将数组分成和相等的三个部分](https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum/)
给你一个整数数组 A，只有可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。

形式上，如果可以找出索引 i+1 < j 且满足 (A[0] + A[1] + ... + A[i] == A[i+1] + A[i+2] + ... + A[j-1] == A[j] + A[j-1] + ... + A[A.length - 1]) 就可以将数组三等分。

 

示例 1：

输出：[0,2,1,-6,6,-7,9,1,2,0,1]
输出：true
解释：0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1
示例 2：

输入：[0,2,1,-6,6,7,9,-1,2,0,1]
输出：false
示例 3：

输入：[3,3,6,5,-2,2,5,1,-9,4]
输出：true
解释：3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4
 

提示：

3 <= A.length <= 50000
-10^4 <= A[i] <= 10^4

```
class Solution:
    def canThreePartsEqualSum(self, A: List[int]) -> bool:
        s = sum(A)
        if s % 3 != 0: return False
        cur = count = 0
        for a in A:
            cur += a 
            if cur == s//3:
                count += 1
                cur = 0
        return count >= 3

# [10,-10,  10,-10,  10,-10,  10,-10] 
```

#### [1071\. 字符串的最大公因子](https://leetcode-cn.com/problems/greatest-common-divisor-of-strings/)
对于字符串 S 和 T，只有在 S = T + ... + T（T 与自身连接 1 次或多次）时，我们才认定 “T 能除尽 S”。

返回最长字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。

 

示例 1：

输入：str1 = "ABCABC", str2 = "ABC"
输出："ABC"
示例 2：

输入：str1 = "ABABAB", str2 = "ABAB"
输出："AB"
示例 3：

输入：str1 = "LEET", str2 = "CODE"
输出：""
 

提示：

1 <= str1.length <= 1000
1 <= str2.length <= 1000
str1[i] 和 str2[i] 为大写英文字母

```
class Solution:
    def gcdOfStrings(self, str1: str, str2: str) -> str:
        if str1 + str2 != str2 + str1: return ""
        length = math.gcd(len(str1), len(str2))
        return str1[:length]
```
```
class Solution:
    def gcdOfStrings(self, str1: str, str2: str) -> str:
        if str1 + str2 != str2 + str1: return ""
        def gcd(a, b):
            return a if b == 0 else gcd(b, a % b)
        length = gcd(len(str1), len(str2))
        return str1[:length]
```
---


#### [169\. 多数元素](https://leetcode-cn.com/problems/majority-element/)
给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

示例 1:

输入: [3,2,3]
输出: 3
示例 2:

输入: [2,2,1,1,1,2,2]
输出: 2

方法一：哈希表
## Python3
```
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        counts = collections.Counter(nums)
        return max(counts.keys(), key = counts.get)
```
## C++
```
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        unordered_map<int, int> counts;
        int majority = 0, cnt = 0;
        for(int num : nums){
            ++ counts[num];
            if(counts[num] > cnt){
                majority = num;
                cnt = counts[num];
            }
        }
        return majority;
    }
};
```
方法二：排序
## Python3
```
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        nums.sort()
        return nums[len(nums)//2]
        
        # sorted_nums = sorted(nums)
        # return sorted_nums[len(nums)//2]
```
## C++
```
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        return nums[nums.size() / 2];
    }
};
```

#### [300\. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)
给定一个无序的整数数组，找到其中最长上升子序列的长度。

示例:

输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
说明:

可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
你算法的时间复杂度应该为 O(n2) 。
进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?

## 方法一：动态规划
复杂度分析

时间复杂度：O(n^2)，其中 nn 为数组 nums 的长度。动态规划的状态数为 n，计算状态 dp[i]时，需要O(n) 的时间遍历 dp[0…i−1] 的所有状态，所以总时间复杂度为 O(n^2)。

空间复杂度：O(n)，需要额外使用长度为 n 的 dp 数组。

## Python3
```
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        if not nums: return 0
        dp = []
        for i in range(n := len(nums)):
            dp.append(1)
            for j in range(i):
                if nums[j] < nums[i]:
                    dp[i] = max(dp[i], dp[j] + 1)
        return max(dp)
```

```
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        if not nums: return 0
        dp = [1] * len(nums)
        for i in range(len(nums)):
            for j in range(i):
                if nums[j] < nums[i]:
                    dp[i] = max(dp[i], dp[j] + 1)
        return max(dp)
```
---
## C++
```
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = (int)nums.size();
        if(n == 0) return 0;
        vector<int> dp(n, 0);

        for(int i = 0; i < n; ++ i){
            dp[i] = 1;
            for(int j = 0; j < i; ++ j){
                if(nums[j] < nums[i])
                    dp[i] = max(dp[i], dp[j]+1);
            }
        }
        return * max_element(dp.begin(), dp.end());

    }
};
```
```
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        if(n == 0) return 0;
        vector<int > dp(n, 1);
        
        for(int i = 0; i < n; ++i){
            for(int j = 0; j < i; ++j){
                if(nums[j] < nums[i])
                    dp[i] = max(dp[i], dp[j] + 1);
            }
        }
        return *max_element(dp.begin(), dp.end());
    }
};
```
```
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        if(n == 0) return 0;
        vector<int> dp(n);
        for(int i = 0; i < n; ++ i){
            dp[i] = 1;
            for(int j = 0; j < i; ++ j){
                if (nums[j] < nums[i]) 
                    dp[i] = max(dp[i], dp[j]+1);       
            }   
        }
        int res = 0;
        for(int i = 0; i < n; i++) res = max(res, dp[i]);
        return res;

    }
};
```

## 方法二：贪心 + 二分查找
以输入序列 [0, 8, 4, 12, 2][0,8,4,12,2] 为例：

第一步插入 00，d = [0]d=[0]；

第二步插入 88，d = [0, 8]d=[0,8]；

第三步插入 44，d = [0, 4]d=[0,4]；

第四步插入 1212，d = [0, 4, 12]d=[0,4,12]；

第五步插入 22，d = [0, 2, 12]d=[0,2,12]。

最终得到最大递增子序列长度为 33。

## Python3
```
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        d = []
        for n in nums:
            if not d or d[-1] < n:
                d.append(n)
            else:   # 二分查找d中第一个比n大的数
                l, r = 0, len(d)
                loc = r # 可以不写
                while l <= r:
                    mid = (l + r) // 2
                    if d[mid] >= n:
                        loc = mid
                        r = mid - 1
                    else:
                        l = mid + 1
                d[loc] = n
        return len(d)
```

复杂度分析

时间复杂度：O(nlogn)。数组nums 的长度为 nn，我们依次用数组中的元素去更新 dd 数组，而更新 dd 数组时需要进行 O(logn) 的二分搜索，所以总时间复杂度为 O(nlogn)。

空间复杂度：O(n)O(n)，需要额外使用长度为 nn 的 dd 数组。


---

#### [695\. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)
给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。

找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。)

示例 1:

[[0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]]
对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。

示例 2:

[[0,0,0,0,0,0,0,0]]
对于上面这个给定的矩阵, 返回 0。

注意: 给定的矩阵grid 的长度和宽度都不超过 50。
## DFS 
```
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        def dfs(gird, i, j):
            if 0<=i<m and  0<=j<n and grid[i][j]:
                grid[i][j] = 0
                return 1 + dfs(grid, i+1, j) + dfs(grid, i-1, j) + \
                           dfs(grid, i, j+1) + dfs(grid, i, j-1)
            return 0
        result = 0
        for x in range(m):
            for y in range(n):
                result = max(result, dfs(grid, x, y))
        return result
```
---
#### [面试题 01.06\. 字符串压缩](https://leetcode-cn.com/problems/compress-string-lcci/)
字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。

示例1:

 输入："aabcccccaaa"
 输出："a2b1c5a3"
示例2:

 输入："abbccd"
 输出："abbccd"
 解释："abbccd"压缩后为"a1b2c2d1"，比原字符串长度更长。
提示：

字符串长度在[0, 50000]范围内。
C++代码：
```
class Solution {
public:
    string compressString(string S) {
        if ((int)S.length() == 0) return S;
        string ans = "";
        char ch = S[0];
        int cnt = 1;
        for (int i = 1; i < (int)S.length(); ++ i){
            if (ch == S[i]) cnt ++;
            else{
                ans += ch + to_string(cnt);
                ch = S[i];
                cnt = 1;   
            }
        }
        ans += ch + to_string(cnt); //加上最后一组字符
        return S.length() <= ans.length() ? S : ans;

    }
};
```
Python3代码：
```
class Solution:
    def compressString(self, S: str) -> str:
        if not S: return S
        ans = ''
        cnt = 0
        ch = S[0]
        for c in S:
            if c == ch: cnt += 1
            else:
                ans += ch + str(cnt)
                ch = c
                cnt = 1
        ans += ch + str(cnt) #保证最后一次统计结果添加到ans
        return ans if len(ans) < len(S) else S
```


#### [1160\. 拼写单词](https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters/)
给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。

假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。

注意：每次拼写时，chars 中的每个字母都只能用一次。

返回词汇表 words 中你掌握的所有单词的 长度之和。

 

示例 1：

输入：words = ["cat","bt","hat","tree"], chars = "atach"
输出：6
解释： 
可以形成字符串 "cat" 和 "hat"，所以答案是 3 + 3 = 6。
示例 2：

输入：words = ["hello","world","leetcode"], chars = "welldonehoneyr"
输出：10
解释：
可以形成字符串 "hello" 和 "world"，所以答案是 5 + 5 = 10。
 

提示：

1 <= words.length <= 1000
1 <= words[i].length, chars.length <= 100
所有字符串中都仅包含小写英文字母

```
class Solution:
    def countCharacters(self, words: List[str], chars: str) -> int:
        ans = 0
        chars_cnt = collections.Counter(chars)
        for word in words:
            word_cnt = collections.Counter(word)
            if all(word_cnt[i] <= chars_cnt[i] for i in word):
                ans += len(word)
        return ans
```

---

#### [836\. 矩形重叠](https://leetcode-cn.com/problems/rectangle-overlap/)
矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。

如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。

给出两个矩形，判断它们是否重叠并返回结果。

示例 1：

输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]
输出：true
示例 2：

输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]
输出：false
说明：

两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。
矩形中的所有坐标都处于 -10^9 和 10^9 之间。

```
class Solution:
    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:
        return not(rec1[2] <= rec2[0] or    #左 rec1 在rec2 的
                   rec1[0] >= rec2[2] or    #右
                   rec1[1] >= rec2[3] or    #上
                   rec1[3] <= rec2[1]       #下
                    )

# 左侧：rec1[2] <= rec2[0]；

# 右侧：rec1[0] >= rec2[2]；

# 上方：rec1[1] >= rec2[3]；

# 下方：rec1[3] <= rec2[1]。

```

#### [409\. 最长回文串](https://leetcode-cn.com/problems/longest-palindrome/)
给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。

在构造过程中，请注意区分大小写。比如 "Aa" 不能当做一个回文字符串。

注意:
假设字符串的长度不会超过 1010。

示例 1:

输入:
"abccccdd"

输出:
7

解释:
我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。
```
class Solution:
    def longestPalindrome(self, s: str) -> int:
        ans = 0
        count = collections.Counter(s)
        for v in count.values():
            ans += v // 2 * 2
            if ans % 2 == 0 and v % 2 == 1:
                ans += 1
        return ans
```
---

#### [面试题40\. 最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)
输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。

 

示例 1：

输入：arr = [3,2,1], k = 2
输出：[1,2] 或者 [2,1]
示例 2：

输入：arr = [0,1,2,1], k = 1
输出：[0]
 

限制：

0 <= k <= arr.length <= 10000
0 <= arr[i] <= 10000


方法一：堆
思路和算法

我们用一个大根堆实时维护数组的前 k 小值。
首先将所有数插入大根堆中，维护一个长度为k的大根堆，堆长度大于k,就把堆顶的数弹出。最后将大根堆里的数存入数组返回即可。在下面的代码中，由于 C++ 语言中的堆（即优先队列）为大根堆，我们可以这么做。而 Python 语言中的堆为小根堆，因此我们要对数组中所有的数取其相反数，才能使用小根堆维护前 k 小值。

复杂度分析

时间复杂度：O(nlogk)，其中 n 是数组 arr 的长度。由于大根堆实时维护前 kk 小值，所以插入删除都是 O(logk) 的时间复杂度，最坏情况下数组里 n 个数都会插入，所以一共需要O(nlogk) 的时间复杂度。

空间复杂度：O(k)，因为大根堆里最多 k 个数。
## 方法一:大根堆
Python 小根堆加负号，变成大根堆
```
class Solution:
    def getLeastNumbers(self, arr: List[int], k: int) -> List[int]:
        if k == 0: 
            return list()

        hq = [-x for x in arr[:k]]
        heapq.heapify(hq)
        for i in range(k, len(arr)):
            if -hq[0] > arr[i]:
                heapq.heappop(hq)
                heapq.heappush(hq, -arr[i])
        res = [-x for x in hq]
        return res
        
```
Python 小根堆加负号，变成大根堆
```
class Solution:
    def getLeastNumbers(self, arr: List[int], k: int) -> List[int]:
        heap, res = [], []
        for x in arr:
            heapq.heappush(heap, -x)
            if len(heap) > k: heapq.heappop(heap)
        while len(heap): 
            res.append(-heap[0])
            heapq.heappop(heap)
        return res
```
C++大根堆
```
class Solution {
public:
    vector<int> getLeastNumbers(vector<int>& arr, int k) {
        vector<int> res;
        priority_queue<int> heap;   //大根堆
        for ( auto x : arr){
            heap.push(x);
            if (heap.size() > k) heap.pop();
        }
        while (heap.size()) res.push_back(heap.top()), heap.pop();
        return res;
    }
};
```
方法二:快排partition划分
```
class Solution:
    def partition(self, nums, l, r):
        pivot = nums[l]
        while l < r:
            while l < r and pivot <= nums[r]:
                r -= 1
            nums[l] = nums[r]
            while l < r and nums[l] <= pivot:
                l += 1
            nums[r] = nums[l]
        nums[l] = pivot
        return l 

    def random_partition(self, nums, l, r):
        import random
        i = random.randint(l, r) # l r内生成一个随机数
        nums[r], nums[i] = nums[i], nums[r] #交换
        return self.partition(nums, l, r) 

    def getLeastNumbers(self, arr: List[int], k: int) -> List[int]:
        if k == 0: return list()
        l, r = 0, len(arr)-1
        idx = self.random_partition(arr, l, r)
        while idx != k - 1:
            if idx < k-1:
                l = idx+1
                idx = self.partition(arr, l, r)
            if idx > k-1:
                r = idx-1
                idx = self.partition(arr, l, r)
        return arr[:k]
```
```
class Solution:
    def getLeastNumbers(self, arr: List[int], k: int) -> List[int]:
        """快排partition划分"""      
        if len(arr) < k or k <= 0: return []
        low, high = 0, len(arr)-1
        idx = self.partition(arr, low, high)
        while idx != k-1:
            if idx < k-1:
                low = idx + 1
                idx = self.partition(arr, low, high)
            if k-1 < idx:
                high = idx - 1
                idx = self.partition(arr, low, high)
        return arr[:k]

    def partition(self, nums, low, high):
        pivot = nums[low]
        while low < high:
            while low < high and pivot <= nums[high]:
                high -= 1 
            nums[low] = nums[high]
            while low < high and nums[low] <= pivot:
                low += 1
            nums[high] = nums[low]
        nums[low] = pivot
        return low

        # arr.sort()
        # return arr[:k]
```
---
#方法二：堆
```
def sink(array, k):
    n = len(array)
    left = 2 * k + 1
    right = 2 * k + 2
    if left >= n: return
    min_i = left 
    if right < n and array[left] > array[right]:
        min_i = right
    if array[min_i] < array[k]:
        array[min_i], array[k] = array[k], array[min_i]
        sink(array, min_i)

def build_heap(list):
    n = len(list)
    for i in range(n//2, -1, -1):
        sink(list, i)

    return list

def GetLeastNumbers_Solution(tinput, k):
    if k > len(tinput): return []
    heap = build_heap(tinput)  # 建堆o(n)复杂度
    res = []
    for _ in range(k):  # 取topk o(klogn)复杂度
        heap[0], heap[-1] = heap[-1], heap[0]
        res.append(heap.pop())
        sink(heap, 0)
    return res

```
---
方法三:排序
Python3
```
class Solution:
    def getLeastNumbers(self, arr: List[int], k: int) -> List[int]:
        # arr.sort()
        # return arr[:k]
        res = sorted(arr)
        return res[:k]
```
C++
```
class Solution {
public:
    vector<int> getLeastNumbers(vector<int>& arr, int k) {
        vector<int>vec(k,0);
        sort(arr.begin(), arr.end());
        for(int i = 0; i < k; ++i) vec[i] = arr[i];
        return vec;
    }
};
```
复杂度分析

时间复杂度：O(nlogn)，其中 n 是数组 arr 的长度。算法的时间复杂度即排序的时间复杂度。

空间复杂度：O(logn)，排序所需额外的空间复杂度为 O(logn)。



#### [365\. 水壶问题](https://leetcode-cn.com/problems/water-and-jug-problem/)
有两个容量分别为 *x*升 和* y*升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 *z*升 的水？

如果可以，最后请用以上水壶中的一或两个来盛放取得的 *z升 *水。

你允许：

*   装满任意一个水壶
*   清空任意一个水壶
*   从一个水壶向另外一个水壶倒水，直到装满或者倒空

**示例 1:** 
输入: x = 3, y = 5, z = 4
输出: True
</pre>

**示例 2:**
输入: x = 2, y = 6, z = 5
输出: False</pre>
方法一：深度优先搜索
思路及算法

首先对题目进行建模。观察题目可知，在任意一个时刻，此问题的状态可以由两个数字决定：X 壶中的水量，以及 Y 壶中的水量。

在任意一个时刻，我们可以且仅可以采取以下几种操作：

把 X 壶的水灌进 Y 壶，直至灌满或倒空；
把 Y 壶的水灌进 X 壶，直至灌满或倒空；
把 X 壶灌满；
把 Y 壶灌满；
把 X 壶倒空；
把 Y 壶倒空。
因此，本题可以使用深度优先搜索来解决。搜索中的每一步以 remain_x, remain_y 作为状态，即表示 X 壶和 Y 壶中的水量。在每一步搜索时，我们会依次尝试所有的操作，递归地搜索下去。这可能会导致我们陷入无止境的递归，因此我们还需要使用一个哈希结合（HashSet）存储所有已经搜索过的 remain_x, remain_y 状态，保证每个状态至多只被搜索一次。

在实际的代码编写中，由于深度优先搜索导致的递归远远超过了 Python 的默认递归层数（可以使用 sys 库更改递归层数，但不推荐这么做），因此下面的代码使用栈来模拟递归，避免了真正使用递归而导致的问题。

复杂度分析

时间复杂度：O(xy)，状态数最多有 (x+1)(y+1) 种，对每一种状态进行深度优先搜索的时间复杂度为O(1)，因此总时间复杂度为O(xy)。

空间复杂度：O(xy)，由于状态数最多有 (x+1)(y+1) 种，哈希集合中最多会有(x+1)(y+1) 项，因此空间复杂度为 O(xy)。

```
class Solution:
    def canMeasureWater(self, x: int, y: int, z: int) -> bool:
        stack = [(0, 0)]
        self.seen = set()
        while stack:
            remain_x, remain_y = stack.pop()
            if remain_x == z or remain_y == z or remain_x + remain_y == z:
                return True
            if (remain_x, remain_y) in self.seen:
                continue
            self.seen.add((remain_x, remain_y))
            # 把 X 壶灌满。
            stack.append((x, remain_y))
            # 把 Y 壶灌满。
            stack.append((remain_x, y))
            # 把 X 壶倒空。
            stack.append((0, remain_y))
            # 把 Y 壶倒空。
            stack.append((remain_x, 0))
            # 把 X 壶的水灌进 Y 壶，直至灌满或倒空。
            stack.append((remain_x - min(remain_x, y - remain_y), remain_y + min(remain_x, y - remain_y)))
            # 把 Y 壶的水灌进 X 壶，直至灌满或倒空。
            stack.append((remain_x + min(remain_y, x - remain_x), remain_y - min(remain_y, x - remain_x)))
        return False
```

---
# 没看懂贪心
#### [945\. 使数组唯一的最小增量](https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/)
给定整数数组 A，每次 move 操作将会选择任意 A[i]，并将其递增 1。

返回使 A 中的每个值都是唯一的最少操作次数。

示例 1:

输入：[1,2,2]
输出：1
解释：经过一次 move 操作，数组将变为 [1, 2, 3]。
示例 2:

输入：[3,2,1,2,1,7]
输出：6
解释：经过 6 次 move 操作，数组将变为 [3, 4, 1, 2, 5, 7]。
可以看出 5 次或 5 次以下的 move 操作是不能让数组的每个值唯一的。
提示：

0 <= A.length <= 40000
0 <= A[i] < 40000
# 没看懂
```
class Solution:
    def minIncrementForUnique(self, A: List[int]) -> int:
        # 贪心算法
        A.sort()
        count = 0
        for i in range(1, len(A)):
            if A[i] <= A[i - 1]:
                count += A[i - 1] - A[i] + 1
                A[i] = A[i - 1] + 1
        return count
```
#### [876\. 链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)
给定一个带有头结点 head 的非空单链表，返回链表的中间结点。

如果有两个中间结点，则返回第二个中间结点。

 

示例 1：

输入：[1,2,3,4,5]
输出：此列表中的结点 3 (序列化形式：[3,4,5])
返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。
注意，我们返回了一个 ListNode 类型的对象 ans，这样：
ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.
示例 2：

输入：[1,2,3,4,5,6]
输出：此列表中的结点 4 (序列化形式：[4,5,6])
由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。
 

提示：

给定链表的结点数介于 1 和 100 之间。

```
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def middleNode(self, head: ListNode) -> ListNode:
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        return slow
```

#### [面试题 17.16\. 按摩师](https://leetcode-cn.com/problems/the-masseuse-lcci/)
一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。

注意：本题相对原题稍作改动

 

示例 1：

输入： [1,2,3,1]
输出： 4
解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。
示例 2：

输入： [2,7,9,3,1]
输出： 12
解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。
示例 3：

输入： [2,1,4,5,3,1,1,3]
输出： 12
解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。


时间复杂度：O(n)
空间复杂度：O(n))
``` python []
class Solution:
    def massage(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [[0]*2 for _ in range(n+1)]
        for i in range(1, n+1):
            dp[i][0] = max(dp[i-1][0], dp[i-1][1])
            dp[i][1] = nums[i-1] + dp[i-1][0]
        return max(dp[n][0], dp[n][1])
```
时间复杂度：O(n)
空间复杂度：O(1)
```python []
class Solution:
    def rob(self, nums: List[int]) -> int:
        yes, no = 0, 0
        for num in nums:
            yes, no = num + no, max(yes, no)
        return max(yes, no)

```
#### [892\. 三维形体的表面积](https://leetcode-cn.com/problems/surface-area-of-3d-shapes/)
在 N * N 的网格上，我们放置一些 1 * 1 * 1  的立方体。

每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。

请你返回最终形体的表面积。

 

示例 1：

输入：[[2]]
输出：10
示例 2：

输入：[[1,2],[3,4]]
输出：34
示例 3：

输入：[[1,0],[0,2]]
输出：16
示例 4：

输入：[[1,1,1],[1,0,1],[1,1,1]]
输出：32
示例 5：

输入：[[2,2,2],[2,1,2],[2,2,2]]
输出：46
 

提示：

1 <= N <= 50
0 <= grid[i][j] <= 50

```
class Solution:
    def surfaceArea(self, grid: List[List[int]]) -> int:
        ans = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] > 0:
                    ans += grid[i][j] * 4 + 2
                if i > 0:
                    ans -= 2 * min(grid[i][j], grid[i - 1][j])
                if j > 0:
                    ans -= 2 * min(grid[i][j], grid[i][j - 1])
        return ans
```

  偷懒待补：
#### [999\. 车的可用捕获量](https://leetcode-cn.com/problems/available-captures-for-rook/)
在一个 8 x 8 的棋盘上，有一个白色车（rook）。也可能有空方块，白色的象（bishop）和黑色的卒（pawn）。它们分别以字符 “R”，“.”，“B” 和 “p” 给出。大写字符表示白棋，小写字符表示黑棋。

车按国际象棋中的规则移动：它选择四个基本方向中的一个（北，东，西和南），然后朝那个方向移动，直到它选择停止、到达棋盘的边缘或移动到同一方格来捕获该方格上颜色相反的卒。另外，车不能与其他友方（白色）象进入同一个方格。

返回车能够在一次移动中捕获到的卒的数量。
 

示例 1：
![](https://upload-images.jianshu.io/upload_images/21384689-31d623ff62aa9787.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



输入：
```
[[".",".",".",".",".",".",".","."],
[".",".",".","p",".",".",".","."],
[".",".",".","R",".",".",".","p"],
[".",".",".",".",".",".",".","."],
[".",".",".",".",".",".",".","."],
[".",".",".","p",".",".",".","."],
[".",".",".",".",".",".",".","."],
[".",".",".",".",".",".",".","."]]
```
输出：3
解释：
在本例中，车能够捕获所有的卒。
示例 2：

![](https://upload-images.jianshu.io/upload_images/21384689-feb9f52b932909bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


输入：
```
[[".",".",".",".",".",".",".","."],
[".","p","p","p","p","p",".","."],
[".","p","p","B","p","p",".","."],
[".","p","B","R","B","p",".","."],
[".","p","p","B","p","p",".","."],
[".","p","p","p","p","p",".","."],
[".",".",".",".",".",".",".","."],
[".",".",".",".",".",".",".","."]]
```
输出：0
解释：
象阻止了车捕获任何卒。
示例 3：

![](https://upload-images.jianshu.io/upload_images/21384689-332edd9314eb1af3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


输入：[[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","p",".",".",".","."],["p","p",".","R",".","p","B","."],[".",".",".",".",".",".",".","."],[".",".",".","B",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."]]
输出：3
解释： 
车可以捕获位置 b5，d6 和 f5 的卒。
 

提示：

board.length == board[i].length == 8
board[i][j] 可以是 'R'，'.'，'B' 或 'p'
只有一个格子上存在 board[i][j] == 'R'

```

class Solution:
    def numRookCaptures(self, board: List[List[str]]) -> int:
        cnt, st, ed = 0, 0, 0
        dx, dy = [0, 1, 0, -1], [1, 0, -1, 0]
        for i in range(8):
            for j in range(8):
                if board[i][j] == "R":
                    st, ed = i, j
        for i in range(4):
            step = 0
            while True:
                tx = st + step * dx[i]
                ty = ed + step * dy[i]
                if tx < 0 or tx >= 8 or ty < 0 or ty >= 8 or board[tx][ty] == "B":
                    break
                if board[tx][ty] == "p":
                    cnt += 1
                    break
                step += 1
        return cnt

```

#### [914\. 卡牌分组](https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards/)
给定一副牌，每张牌上都写着一个整数。

此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：

每组都有 X 张牌。
组内所有的牌上都写着相同的整数。
仅当你可选的 X >= 2 时返回 true。

 

示例 1：

输入：[1,2,3,4,4,3,2,1]
输出：true
解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]
示例 2：

输入：[1,1,1,2,2,2,3,3]
输出：false
解释：没有满足要求的分组。
示例 3：

输入：[1]
输出：false
解释：没有满足要求的分组。
示例 4：

输入：[1,1]
输出：true
解释：可行的分组是 [1,1]
示例 5：

输入：[1,1,2,2,2,2]
输出：true
解释：可行的分组是 [1,1]，[2,2]，[2,2]

提示：

1 <= deck.length <= 10000
0 <= deck[i] < 10000

```
class Solution(object):
    def hasGroupsSizeX(self, deck):
        from fractions import gcd
        vals = collections.Counter(deck).values()
        return reduce(gcd, vals) >= 2

```

#### [820\. 单词的压缩编码](https://leetcode-cn.com/problems/short-encoding-of-words/)
给定一个单词列表，我们将这个列表编码成一个索引字符串 S 与一个索引列表 A。

例如，如果这个列表是 ["time", "me", "bell"]，我们就可以将其表示为 S = "time#bell#" 和 indexes = [0, 2, 5]。

对于每一个索引，我们可以通过从字符串 S 中索引的位置开始读取字符串，直到 "#" 结束，来恢复我们之前的单词列表。

那么成功对给定单词列表进行编码的最小字符串长度是多少呢？

 

示例：

输入: words = ["time", "me", "bell"]
输出: 10
说明: S = "time#bell#" ， indexes = [0, 2, 5] 。
 

提示：

1 <= words.length <= 2000
1 <= words[i].length <= 7
每个单词都是小写字母 。

```
class Solution:
    def minimumLengthEncoding(self, words: List[str]) -> int:
        words = list(set(words)) #remove duplicates
        #Trie is a nested dictionary with nodes created
        # when fetched entries are missing
        Trie = lambda: collections.defaultdict(Trie)
        trie = Trie()

        #reduce(..., S, trie) is trie[S[0]][S[1]][S[2]][...][S[S.length - 1]]
        nodes = [reduce(dict.__getitem__, word[::-1], trie)
                 for word in words]

        #Add word to the answer if it's node has no neighbors
        return sum(len(word) + 1
                   for i, word in enumerate(words)
                   if len(nodes[i]) == 0)

```
#### [1162\. 地图分析](https://leetcode-cn.com/problems/as-far-from-land-as-possible/)
你现在手里有一份大小为 N x N 的『地图』（网格） grid，上面的每个『区域』（单元格）都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地，你知道距离陆地区域最远的海洋区域是是哪一个吗？请返回该海洋区域到离它最近的陆地区域的距离。

我们这里说的距离是『曼哈顿距离』（ Manhattan Distance）：(x0, y0) 和 (x1, y1) 这两个区域之间的距离是 |x0 - x1| + |y0 - y1| 。

如果我们的地图上只有陆地或者海洋，请返回 -1。

 

示例 1：

![](https://upload-images.jianshu.io/upload_images/21384689-21f534970e8833f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


输入：[[1,0,1],[0,0,0],[1,0,1]]
输出：2
解释： 
海洋区域 (1, 1) 和所有陆地区域之间的距离都达到最大，最大距离为 2。
示例 2：

![](https://upload-images.jianshu.io/upload_images/21384689-4fb8240992550e75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


输入：[[1,0,0],[0,0,0],[0,0,0]]
输出：4
解释： 
海洋区域 (2, 2) 和所有陆地区域之间的距离都达到最大，最大距离为 4。
 

提示：

1 <= grid.length == grid[0].length <= 100
grid[i][j] 不是 0 就是 1

```
class Solution {
public:
    static constexpr int MAX_N = 100 + 5;
    static constexpr int INF = int(1E6);
    static constexpr int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

    int n;
    int d[MAX_N][MAX_N];

    struct Status {
        int v, x, y;
        bool operator < (const Status &rhs) const {
            return v > rhs.v;
        }
    };

    priority_queue <Status> q;

    int maxDistance(vector<vector<int>>& grid) {
        this->n = grid.size();
        auto &a = grid;

        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                d[i][j] = INF;
            }
        }

        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (a[i][j]) {
                    d[i][j] = 0;
                    q.push({0, i, j});
                }
            }
        }

        while (!q.empty()) {
            auto f = q.top(); q.pop();
            for (int i = 0; i < 4; ++i) {
                int nx = f.x + dx[i], ny = f.y + dy[i];
                if (!(nx >= 0 && nx <= n - 1 && ny >= 0 && ny <= n - 1)) continue;
                if (f.v + 1 < d[nx][ny]) {
                    d[nx][ny] = f.v + 1;
                    q.push({d[nx][ny], nx, ny});
                }
            }
        }

        int ans = -1;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (!a[i][j]) ans = max(ans, d[i][j]);
            }
        }

        return (ans == INF) ? -1 : ans;
    }
};
```









#### [面试题62\. 圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)
0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。

例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。

 

示例 1：

输入: n = 5, m = 3
输出: 3
示例 2：

输入: n = 10, m = 17
输出: 2
 

限制：

1 <= n <= 10^5
1 <= m <= 10^6

Python
```
class Solution:
    def lastRemaining(self, n: int, m: int) -> int:
        flag = 0
        for i in range(2,n+1):
            flag = (flag + m) % i 
        return flag
```

```
class Solution:
    def lastRemaining(self, n: int, m: int) -> int:
        f = 0 
        for i in range(2, n+1):
            f = (f + m) % i 
        return f 
```
复杂度分析

时间复杂度：O(n)，需要求解的函数值有 n 个。

空间复杂度：O(1)，只使用常数个变量。
```
class Solution:
    def lastRemaining(self, n: int, m: int) -> int:
        if n == 1: return 0 
        return (self.lastRemaining(n-1, m) + m) % n
```
C++
```
class Solution {
public:
    int lastRemaining(int n, int m) {
        int f = 0;
        for (int i = 2; i != n+1; ++i)
            f = (f + m) % i ;
        return f;

    }
};
```
```
class Solution {
public:
    int lastRemaining(int n, int m) {
        int flag = 0;
        for (int i = 2; i <= n; i ++)
            flag = (flag + m ) % i ;
        return flag;
    }
};
```
```
class Solution {
public:
    int lastRemaining(int n, int m) {
        if (n == 1) return 0;
        return (lastRemaining(n-1, m) + m) % n;
    }
};
```

复杂度分析

时间复杂度：O(n)，需要求解的函数值有 n 个。

空间复杂度：O(n)，函数的递归深度为 n，需要使用 O(n) 的栈空间。
---

#### [912\. 排序数组](https://leetcode-cn.com/problems/sort-an-array/)
给定一个整数数组 nums，将该数组升序排列。

 

示例 1：

输入：[5,2,3,1]
输出：[1,2,3,5]
示例 2：

输入：[5,1,1,2,0,0]
输出：[0,0,1,1,2,5]
 

提示：

1 <= A.length <= 10000
-50000 <= A[i] <= 50000

### 方法一：快速排序
思路和算法

快速排序的主要思想是通过划分将待排序的序列分成前后两部分，其中前一部分的数据都比后一部分的数据要小，然后再递归调用函数对两部分的序列分别进行快速排序，以此使整个序列达到有序。

```
class Solution:
    def partition(self, nums, l, r):
        pivot = nums[l]
        while l < r:
            while l < r and pivot <= nums[r]:
                r -= 1
            nums[l] = nums[r] 
            while l < r and nums[l] <= pivot:
                l += 1 
            nums[r] = nums[l]
        nums[l] = pivot
        return l
    def random_partition(self, nums, l, r):
        i = random.randint(l, r)
        nums[i], nums[r] = nums[r], nums[i]  
        return self.partition(nums, l, r)
    def quickSort(self, nums, l, r):
        if l < r:
            k = self.random_partition(nums, l, r)
            self.quickSort(nums, l, k-1)
            self.quickSort(nums, k+1, r)
    def sortArray(self, nums: List[int]) -> List[int]:
        self.quickSort(nums, 0, len(nums)-1 )
        return nums
```
复杂度分析

时间复杂度：基于随机选取主元的快速排序时间复杂度为期望 O(nlogn)，其中 nn 为数组的长度。详细证明过程可以见《算法导论》第七章，这里不再大篇幅赘述。

空间复杂度：O(h)，其中 h 为快速排序递归调用的层数。我们需要额外的 O(h) 的递归调用的栈空间，由于划分的结果不同导致了快速排序递归调用的层数也会不同，最坏情况下需O(n) 的空间，最优情况下每次都平衡，此时整个递归树高度为logn，空间复杂度为 O(logn)。
















1.优化的冒泡(超出)
```
class Solution:
    def bubble_sort(nums):
        for i in range(len(nums) - 1):  
            flag = False  # 改进后的冒泡，设置一个交换标志位
            for j in range(len(nums) - i - 1):  
                if nums[j] > nums[j + 1]:
                    nums[j], nums[j + 1] = nums[j + 1], nums[j]
                    flag = True
            if not flag:
                return nums  # 这里代表计算机偷懒成功。
```
2.选择排序(超出)
```
class Solution:
    def selection_sort(nums): 
        for i in range(len(nums)): 
            min_idx = i 
            for j in range(i+1, len(nums)): 
                if nums[min_idx] > nums[j]: 
                    min_idx = j 
                        
            nums[i], nums[min_idx] = nums[min_idx], nums[i] 
        return nums
```
3.插入排序
从第二个元素开始和前面的元素进行比较，如果前面的元素比当前元素大，则将前面元素 后移，当前元素依次往前，直到找到比它小或等于它的元素插入在其后面。
```
class Solution:
    def insertion_sort(nums):
        # 第一层for表示循环插入的遍数
        for i in range(1, len(nums)):
            for j in range(i, 0,  -1):
                if nums[j] < nums[j-1]:
                    nums[j], nums[j-1] = nums[j-1], nums[j]
                else:
                    break
        return nums
  ```      
4.快速排序
**任意选取一个数据（通常选用数组的第一个数或最后一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。 **
```
class Solution:
    def partition(arr,low,high): 
        i = (low-1)         # 最小元素索引
        pivot = arr[high]     
        for j in range(low,high): 
        # 当前元素小于或等于 pivot 
            if   arr[j] <= pivot: 
                i = i+1 
                arr[i], arr[j] = arr[j], arr[i] 
        arr[i+1], arr[high] = arr[high], arr[i+1] 
        return i+1  
    def quickSort(arr,low,high): 
        if low < high:
            pi = partition(arr, low, high) 
            quickSort(arr, low, pi-1) 
            quickSort(arr, pi+1, high) 
        n = len(arr) 
        quickSort(arr, 0, n-1) 
```
5.归并排序
```
class Solution:
    def merge_sort(arr):
        if len(arr) == 1: return arr
        mid = len(arr) // 2
        left = arr[:mid]
        right = arr[mid:]
        return marge(merge_sort(left), merge_sort(right))
    def marge(left, right):
        res = []
        while len(left) > 0 and len(right) > 0:
        # 左右两个数列第一个最小放前面
            if left[0] <= right[0]:
                res.append(left.pop(0))
            else:
                res.append(right.pop(0))
        # 只有一个数列中还有值，直接添加
        res += left
        res += right
        return res
 ```  
6.桶排序（牺牲空间）
```
class Solution:
    def bucket_sort(s):
        min_num = min(s)
        max_num = max(s)
        # 桶的大小
        bucket_range = (max_num-min_num) / len(s)
        # 桶数组
        count_list = [ [] for i in range(len(s) + 1)]
        # 向桶数组填数
        for i in s:
            count_list[int((i-min_num)//bucket_range)].append(i)
        s.clear()
        # 回填，这里桶内部排序直接调用了sorted
        for i in count_list:
            for j in sorted(i):
            s.append(j)
 ```     
7.计数排序 --当数值中有非整数时，计数数组的索引无法分配
```
class Solution:
    def count_sort(s):
        # 找到最大最小值
        min_num = min(s)
        max_num = max(s)
        # 计数列表
        count_list = [0]*(max_num-min_num+1)
        # 计数
        for i in s:
            count_list[i-min_num] += 1
        s.clear()
        # 填回
        for ind,i in enumerate(count_list):
            while i != 0:
            s.append(ind+min_num)
            i -= 1
```
8.希尔排序（减小增量排序）
** 希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。
希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录"基本有序"时，再对全体记录进行依次直接插入排序。**
```
class solution:
    def shell_sort(s):
        b = len(s)                         #列表长度
        gap = b // 2                       #初始步长设置为总长度的一半
        while gap >= 1:
            for i in range (b):
                j = i
                while j >= gap and s[j-gap] > s[j]:   #在每一组里面进行直接插入排序
                    s[j], s[j-gap] = s[j-gap], s[j]
                    j-= gap
            gap = gap//2                              #更新步长
```
9.堆排序
```
class Solution:
    def heapify(arr, n, i): 
        largest = i  
        l = 2 * i + 1     # left = 2*i + 1 
        r = 2 * i + 2     # right = 2*i + 2 
    
        if l < n and arr[i] < arr[l]: 
            largest = l 
    
        if r < n and arr[largest] < arr[r]: 
            largest = r 
    
        if largest != i: 
            arr[i],arr[largest] = arr[largest],arr[i]  # 交换
    
            heapify(arr, n, largest) 
    
    def heapSort(arr): 
        n = len(arr) 
    
        # Build a maxheap. 
        for i in range(n, -1, -1): 
            heapify(arr, n, i) 
    
        # 一个个交换元素
        for i in range(n-1, 0, -1): 
            arr[i], arr[0] = arr[0], arr[i]   # 交换
            heapify(arr, i, 0) 
```
10.基数排序
```
class Solution:
    def radix_sort(s):
        """基数排序"""
        i = 0 # 记录当前正在排拿一位，最低位为1
        max_num = max(s)  # 最大值
        j = len(str(max_num))  # 记录最大值的位数
        while i < j:
            bucket_list =[[] for _ in range(10)] #初始化桶数组
            for x in s:
                bucket_list[int(x / (10**i)) % 10].append(x) # 找到位置放入桶数组
            s.clear()
            for x in bucket_list:   # 放回原序列
                for y in x:
                    s.append(y)
            i += 1
```
